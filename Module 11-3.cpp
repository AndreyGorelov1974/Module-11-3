/*Задание 3. Валидация IP-адреса
Что нужно сделать
Проверьте, задаёт ли введённая пользователем строка корректный IP-адрес четвёртой версии (IPv4).
IP-адрес должен представлять из себя четыре числа, разделённые точками без пробелов, причём каждое число должно быть в диапазоне от 0 до 255 включительно.
Числа не должны содержать ведущих нулей. Других символов в строке, кроме вышеописанных, быть не должно.

Пользователь вводит строку, задающую IP-адрес через стандартный ввод.
В результате программа должна вывести слово Valid, если адрес корректен, и слово Invalid, если это не так.

Примеры

Корректные: 
127.0.0.1 
255.255.255.255 
1.2.3.4 
55.77.213.101

Некорректные: 
255.256.257.258 (есть числа больше 255) 
0.55.33.22. (лишняя точка в конце) 
10.00.000.0 (лишние нули) 
23.055.255.033 (опять лишние нули) 
65.123..9 (две точки подряд) 
a.b.c.d (посторонние символы вместо чисел и точек)

Рекомендации
Активно используйте оператор индексации строки str[i], но помните, что индексы начинаются с нуля, а не с единицы.
Создайте отдельную функцию для получения отдельных чисел из IP-адреса и валидируйте эти отдельные числа.
Для валидации отдельных цифр у чисел следует использовать оператор сравнения с константами символов. Символы от ‘0’ до ‘9’ расположены последовательно и поэтому уместны операторы <= и >=.
Вам потребуется функция, принимающая на вход строку со всем IP-адресом и порядковый номер октета.
Октет — это часть IP-адреса между точками. Он содержится в восьми битах, отсюда и название (окта — восемь).
2^8 = 256. Отсюда уже предел значения октета — 255. То есть вызов get_address_part(“192.168.1.1”, 1) вернёт 168.
Данная функция проходит по всей строке и ищет разделители — точки, одновременно с этим накапливает символы в строку, которую вернёт в результате.
При нахождении разделителя нужно вернуть полученную строку.
Проверку её корректности нужно делать в другой функции (проверить длину == 3 и то, что число в строке находится в диапазоне [0,255] ).*/

#include <iostream>
#include <string>

// функция вырезания октета оп его номерн
std::string cut_octet(std::string str, int number) {
	std::string result = "";
	int count = 1;
	for (int i = 0; i < str.length(); i++) {
		if (str[i] != '@') {
			result += str[i];
		}
		else {
			return result;
		}
	}
	return result = "";
}

//функция проверки IP адреса
bool check_IP(std::string checkAddress) {
	//отсеваем IP c некорректной длиной, и начинающиеся и заканчивающиеся символом '.'
	if (checkAddress.length() < 7 || checkAddress.length() > 15 || checkAddress[0] < '.' || checkAddress[checkAddress.length()-1] < '.') {
		return false;
	}

	//отсеваем IP c двумя символами '.' подряд, и неккоректными символами
	for (int i = 0; i < checkAddress.length(); i++) {
		if (checkAddress[i] == '.' && checkAddress[i + 1] == '.' && i < (checkAddress.length() - 1)) {
			return false;
		}
		if (checkAddress[i] < '0' || checkAddress[i] > '9' || checkAddress[i] != '.') {
			return false;
		}
	}

	// проверяем корректность октетов
	for (int i = 1; i <= 4; i++) {
		std::string currentOctetStr = cut_octet(checkAddress, i);
		int currentOctet = std::stoi(currentOctetStr);
		// длина октета больше 3
		if (currentOctetStr.length() > 3) {
			return false;
		}
		// число меньше 0 или больше 255
		if (currentOctet < 0 || currentOctet > 255) {
			return false;
		}
		// ведущие нули для чисел 0-9
		if (currentOctet >= 0 && currentOctet <= 9 && currentOctetStr.length() < 1) {
			return false;
		}
		// ведущие нули для чисел 10-99

		if (currentOctet >= 10 && currentOctet <= 99 && currentOctetStr.length() < 2) {
			return false;
		}
	}
	return true;
}



int main() {
	std::string IPAddress;
	std::cout << "Enter IP address: ";
	std::cin >> IPAddress;
	
	std::cout << (check_IP(IPAddress) ? "Valid" : "Invalid");
}